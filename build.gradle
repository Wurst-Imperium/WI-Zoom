buildscript {
	dependencies {
		classpath "org.kohsuke:github-api:1.326"
	}
}

plugins {
	id "java-library"
	id "eclipse"
	id "idea"
	id "net.neoforged.gradle.userdev" version "7.0.146"
	id "net.neoforged.gradle.mixin" version "7.0.146"
	id "me.modmuss50.mod-publish-plugin" version "0.5.2"
	id "com.diffplug.spotless" version "6.25.0"
}

tasks.named('wrapper', Wrapper).configure {
	distributionType = Wrapper.DistributionType.ALL
}

def ENV = System.getenv()

version = project.mod_version
group = project.mod_group_id

repositories {
	mavenLocal()
}

base {
	archivesName = project.mod_name.replace(" ", "-")
}

// Mojang ships Java 21 to end users starting in 1.20.5 (24w14a), so mods should target Java 21.
java.toolchain.languageVersion = JavaLanguageVersion.of(21)

mixin {
	config 'wi-zoom.mixins.json'
}

//minecraft.accessTransformers.file rootProject.file('src/main/resources/META-INF/accesstransformer.cfg')
//minecraft.accessTransformers.entry public net.minecraft.client.Minecraft textureManager # textureManager

// Default run configurations.
// These can be tweaked, removed, or duplicated as needed.
runs {
	// applies to all the run configs below
	configureEach {
		// Recommended logging data for a userdev environment
		// The markers can be added/remove as needed separated by commas.
		// "SCAN": For mods scan.
		// "REGISTRIES": For firing of registry events.
		// "REGISTRYDUMP": For getting the contents of all registries.
		systemProperty 'forge.logging.markers', 'REGISTRIES'
		
		// Recommended logging level for the console
		// You can set various levels here.
		// Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
		systemProperty 'forge.logging.console.level', 'debug'
		
		modSource project.sourceSets.main
	}
	
	client {
		// Comma-separated list of namespaces to load gametests from. Empty = all namespaces.
		systemProperty 'forge.enabledGameTestNamespaces', project.mod_id
	}
	
	server {
		systemProperty 'forge.enabledGameTestNamespaces', project.mod_id
		programArgument '--nogui'
	}
	
	// This run config launches GameTestServer and runs all registered gametests, then exits.
	// By default, the server will crash when no gametests are provided.
	// The gametest system is also enabled by default for other run configs under the /test command.
	gameTestServer {
		systemProperty 'forge.enabledGameTestNamespaces', project.mod_id
	}
	
	data {
		// example of overriding the workingDirectory set in configureEach above, uncomment if you want to use it
		// workingDirectory project.file('run-data')
		
		// Specify the modid for data generation, where to output the resulting resource, and where to look for existing resources.
		programArguments.addAll '--mod', project.mod_id, '--all', '--output', file('src/generated/resources/').getAbsolutePath(), '--existing', file('src/main/resources/').getAbsolutePath()
	}
}

// Include resources generated by data generators.
sourceSets.main.resources { srcDir 'src/generated/resources' }

// Sets up a dependency configuration called 'localRuntime'.
// This configuration should be used instead of 'runtimeOnly' to declare
// a dependency that will be present for runtime testing but that is
// "optional", meaning it will not be pulled by dependents of this mod.
configurations {
	runtimeClasspath.extendsFrom localRuntime
}

configurations.all {
	resolutionStrategy {
		force "com.microsoft.azure:msal4j:1.17.2"
		// Override vulnerable netty-common dependency until Minecraft updates
		// to a newer version. v4.1.97.Final, used by Minecraft 1.21 - 1.21.3,
		// is vulnerable to CVE-2024-47535.
		force "io.netty:netty-common:4.1.115.Final"
	}
}

dependencies {
	// Specify the version of Minecraft to use.
	// Depending on the plugin applied there are several options. We will assume you applied the userdev plugin as shown above.
	// The group for userdev is net.neoforged, the module name is neoforge, and the version is the same as the neoforge version.
	// You can however also use the vanilla plugin (net.neoforged.gradle.vanilla) to use a version of Minecraft without the neoforge loader.
	// And its provides the option to then use net.minecraft as the group, and one of; client, server or joined as the module name, plus the game version as version.
	// For all intends and purposes: You can treat this dependency as if it is a normal library you would use.
	implementation "net.neoforged:neoforge:${neo_version}"
	
	// Example optional mod dependency with JEI
	// The JEI API is declared for compile time use, while the full JEI artifact is used at runtime
	// compileOnly "mezz.jei:jei-${mc_version}-common-api:${jei_version}"
	// compileOnly "mezz.jei:jei-${mc_version}-neoforge-api:${jei_version}"
	// We add the full version to localRuntime, not runtimeOnly, so that we do not publish a dependency on it
	// localRuntime "mezz.jei:jei-${mc_version}-neoforge:${jei_version}"
	
	// Example mod dependency using a mod jar from ./libs with a flat dir repository
	// This maps to ./libs/coolmod-${mc_version}-${coolmod_version}.jar
	// The group id is ignored when searching -- in this case, it is "blank"
	// implementation "blank:coolmod-${mc_version}:${coolmod_version}"
	
	// Example mod dependency using a file as dependency
	// implementation files("libs/coolmod-${mc_version}-${coolmod_version}.jar")
	
	// Example project dependency using a sister or child project:
	// implementation project(":myproject")
	
	// For more info:
	// http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
	// http://www.gradle.org/docs/current/userguide/dependency_management.html
}

// This block of code expands all declared replace properties in the specified resource targets.
// A missing property will result in an error. Properties are expanded using ${} Groovy notation.
// When "copyIdeResources" is enabled, this will also run before the game launches in IDE environments.
// See https://docs.gradle.org/current/dsl/org.gradle.language.jvm.tasks.ProcessResources.html
tasks.withType(ProcessResources).configureEach {
	var replaceProperties = [
			minecraft_version      : minecraft_version,
			minecraft_version_range: minecraft_version_range,
			neo_version            : neo_version,
			neo_version_range      : neo_version_range,
			loader_version_range   : loader_version_range,
			mod_id                 : mod_id,
			mod_name               : mod_name,
			mod_license            : mod_license,
			mod_version            : mod_version,
			mod_authors            : mod_authors,
			mod_description        : mod_description
	]
	inputs.properties replaceProperties
	
	filesMatching(['META-INF/neoforge.mods.toml']) {
		expand replaceProperties
	}
}

tasks.withType(JavaCompile).configureEach {
	options.encoding = 'UTF-8' // Use the UTF-8 charset for Java compilation
}

// IDEA no longer automatically downloads sources/javadoc jars for dependencies, so we need to explicitly enable the behavior.
idea {
	module {
		downloadSources = true
		downloadJavadoc = true
	}
}

spotless {
	lineEndings("WINDOWS")
	java {
		removeUnusedImports()
		indentWithTabs()
		trimTrailingWhitespace()
		eclipse().configFile(file("codestyle/formatter.xml"))
	}
	json {
		target "src/**/*.json"
		gson().indentWithSpaces(2).version("2.10.1")
	}
}

def getGhVersion() {
	return "v" + version.substring(0, version.indexOf("-MC"))
}

def getChangelogUrl() {
	def modSlug = mod_name.toLowerCase().replace(" ", "-")
	def versionSlug = version.substring(0, version.indexOf("-MC")).replace(".", "-")
	return "https://www.wimods.net/${modSlug}/${modSlug}-${versionSlug}/"
}

publishMods {
	file = tasks.named("jar").flatMap { task ->
		def libsDir = layout.buildDirectory.dir("libs").get().asFile
		def jarFiles = libsDir.listFiles().findAll { it.name.endsWith(".jar") }
		layout.file(providers.provider { jarFiles[0] })
	}
	type = getGhVersion().contains("pre") ? BETA : STABLE
	modLoaders.add("neoforge")
	def changelogUrl = getChangelogUrl()
	
	curseforge {
		projectId = "349630"
		accessToken = providers.environmentVariable("CURSEFORGE_API_KEY")
		minecraftVersions.add("${project.cf_game_version}")
		changelog = "A changelog can be found at: [${changelogUrl}](${changelogUrl}?mc=${project.minecraft_version}&utm_source=CurseForge&utm_medium=WI+Zoom&utm_campaign=Changelog&utm_content=CurseForge+WI+Zoom+MC${project.minecraft_version}-NeoForge)"
	}
	modrinth {
		projectId = "o7DitHWP"
		accessToken = providers.environmentVariable("MODRINTH_TOKEN")
		minecraftVersions.add("${project.minecraft_version}")
		changelog = "A changelog can be found at: [${changelogUrl}](${changelogUrl}?mc=${project.minecraft_version}&utm_source=Modrinth&utm_medium=WI+Zoom&utm_campaign=Changelog&utm_content=Modrinth+WI+Zoom+MC${project.minecraft_version}-NeoForge)"
	}
}

tasks.named("publishMods").configure {
	dependsOn(tasks.named("build"))
}

tasks.named("publishCurseforge").configure {
	dependsOn(tasks.named("build"))
}

tasks.named("publishModrinth").configure {
	dependsOn(tasks.named("build"))
}

import org.kohsuke.github.GHReleaseBuilder
import org.kohsuke.github.GitHub

task github {
	dependsOn tasks.named("build")
	
	onlyIf {
		ENV.GITHUB_TOKEN
	}
	
	doLast {
		def github = GitHub.connectUsingOAuth(ENV.GITHUB_TOKEN as String)
		def repository = github.getRepository("Wurst-Imperium-MCX/WI-Zoom")
		def ghVersion = getGhVersion()
		
		def ghRelease = repository.getReleaseByTagName(ghVersion as String)
		if(ghRelease == null) {
			def releaseBuilder = new GHReleaseBuilder(repository, ghVersion as String)
			releaseBuilder.prerelease(ghVersion.contains("pre"))
			ghRelease = releaseBuilder.create()
		}
		
		def libsDir = layout.buildDirectory.dir("libs").get().asFile
		def jarFiles = libsDir.listFiles().findAll { it.name.endsWith(".jar") }
		File publishJar = jarFiles[0]
		
		ghRelease.uploadAsset(publishJar, "application/java-archive")
	}
}

import java.time.LocalDate
import org.kohsuke.github.GHIssueState
import org.kohsuke.github.GHMilestoneState
import java.time.ZoneId

task closeMilestone {
	onlyIf {
		ENV.GITHUB_TOKEN
	}
	
	doLast {
		def github = GitHub.connectUsingOAuth(ENV.GITHUB_TOKEN as String)
		def repository = github.getRepository("Wurst-Imperium/WI-Zoom")
		def ghVersion = getGhVersion()
		
		// Weird API design: listMilestones() requires GHIssueState while everything else uses GHMilestoneState.
		def milestone = repository.listMilestones(GHIssueState.ALL).find { it.title == ghVersion }
		if (milestone == null) {
			milestone = repository.createMilestone(ghVersion, "")
		}
		
		if (milestone.getState() != GHMilestoneState.CLOSED) {
			milestone.setDueOn(Date.from(LocalDate.now().atStartOfDay(ZoneId.systemDefault()).toInstant()))
			milestone.setDescription(getChangelogUrl())
			milestone.close()
		}
	}
}

task uploadBackups {
	dependsOn tasks.named("build")
	
	onlyIf {
		ENV.WI_BACKUPS_API_KEY
	}
	
	doLast {
		def shortVersion = getGhVersion().substring(1)
		def backupUrl = "https://api.wurstclient.net/artifact-backups/WI-Zoom/${shortVersion}"
		
		def connection = new URL(backupUrl).openConnection() as HttpURLConnection
		def boundary = UUID.randomUUID().toString()
		connection.setRequestMethod("POST")
		connection.setRequestProperty("X-API-Key", ENV.WI_BACKUPS_API_KEY)
		connection.setRequestProperty("Accept", "application/json")
		connection.setRequestProperty("Content-Type", "multipart/form-data; boundary=$boundary")
		connection.doOutput = true
		
		def output = connection.outputStream
		def libsDir = layout.buildDirectory.dir("libs").get().asFile
		def jarFiles = libsDir.listFiles().findAll { it.name.endsWith(".jar") }
		
		jarFiles.each { file ->
			output << "--${boundary}\r\n"
			output << "Content-Disposition: form-data; name=\"files\"; filename=\"${file.name}\"\r\n"
			output << "Content-Type: application/java-archive\r\n\r\n"
			file.withInputStream { input -> 
				output << input
			}
			output << "\r\n"
		}
		output << "--${boundary}--\r\n"
		output.flush()
		
		if(connection.responseCode != 200)
			throw new GradleException("Failed to upload backups: ${connection.responseCode} ${connection.responseMessage}")
	}
}
